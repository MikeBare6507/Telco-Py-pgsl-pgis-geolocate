import pandas as pd
import geopandas as gpd
from shapely.wkt import loads as wkt_loads
from sqlalchemy import create_engine
from sqlalchemy import text
from sklearn.cluster import KMeans
import os
import random
from shapely.ops import nearest_points
import warnings


# Suppress specific warnings from scikit-learn
warnings.filterwarnings("ignore", category=UserWarning, module='sklearn.cluster._kmeans')

# Set the number of threads for KMeans to avoid memory leak
os.environ["OMP_NUM_THREADS"] = "2"  # Set to 1 or 2 to reduce the chance of memory leaks

def fetch_data():
    # Create SQLAlchemy engine for connection
    engine = create_engine('postgresql://postgres:0624@localhost/Telco2')

    # Define SQL queries
    cid_query = "SELECT cid, mkt_id, fip, cid_geom FROM cid_kmeans_gen;"
    eid_query = "SELECT eid, mkt_id FROM eid_employees;"

    # Fetch data from the database
    cid_df = pd.read_sql(cid_query, engine)
    eid_df = pd.read_sql(eid_query, engine)
    

    # Convert cid_geom to geometry
    cid_df['geometry'] = cid_df['cid_geom'].apply(wkt_loads)
    cid_gdf = gpd.GeoDataFrame(cid_df, geometry='geometry')

    return cid_gdf, eid_df  # Return GeoDataFrame and eid DataFrame

def apply_kmeans_per_market(cid_gdf, eid_df):
    cid_gdf['cluster'] = None  # Initialize column for cluster assignment

    for market_id in cid_gdf['mkt_id'].unique():
        # Filter data for the market
        market_cid_gdf = cid_gdf[cid_gdf['mkt_id'] == market_id].copy()
        market_eid_df = eid_df[eid_df['mkt_id'] == market_id]
        
        num_cids = len(market_cid_gdf)
        num_eids = len(market_eid_df)

        # Set clusters equal to the number of EIDs
        num_clusters = num_eids

        # Get coordinates for clustering
        coordinates = list(market_cid_gdf['geometry'].apply(lambda geom: (geom.x, geom.y)))

        # Apply K-Means clustering
        kmeans = KMeans(n_clusters=num_clusters)
        market_cid_gdf['cluster'] = kmeans.fit_predict(coordinates)
        
        # Assign clusters back to the original GeoDataFrame
        cid_gdf.loc[market_cid_gdf.index, 'cluster'] = market_cid_gdf['cluster']

    return cid_gdf

def assign_eids_to_clusters(cid_gdf, eid_df):
    assignments = []

    for market_id in cid_gdf['mkt_id'].unique():
        # Filter data for the market
        market_cid_gdf = cid_gdf[cid_gdf['mkt_id'] == market_id].copy()
        market_eid_df = eid_df[eid_df['mkt_id'] == market_id]
        
        num_clusters = market_cid_gdf['cluster'].nunique()
        num_eids = len(market_eid_df)

        # Assign EIDs in a balanced way
        eids = list(market_eid_df['eid'])
        random.shuffle(eids)  # Shuffle EIDs to randomize assignments
        
        cluster_groups = market_cid_gdf.groupby('cluster')
        mean_cids_per_eid = len(market_cid_gdf) // num_eids
        max_cids_per_eid = mean_cids_per_eid + 5  # Set an upper bound for assignments

        # Initialize counters to track assignments
        eid_counts = {eid: 0 for eid in eids}

        for cluster, cids in cluster_groups:
            for idx, row in cids.iterrows():
                # Find the EID with the least assignments within bounds
                available_eids = [eid for eid in eids if eid_counts[eid] < max_cids_per_eid]
                if not available_eids:
                    available_eids = eids  # Fallback if all exceed bounds
                
                eid = random.choice(available_eids)
                eid_counts[eid] += 1

                assignments.append({'cid': row['cid'], 'eid': eid})
    
    return pd.DataFrame(assignments)

def insert_assignments(assignments_df):
    if assignments_df.empty:
        print("No data to insert.")
        return

    # Prepare data for insertion
    data = list(assignments_df.itertuples(index=False, name=None))
    print(f"Prepared data for insertion: {data[:5]}")  # Print the first few tuples

    insert_query = """
    INSERT INTO cid_eid (cid, eid)
    VALUES (:cid, :eid)
    ON CONFLICT (cid) DO UPDATE SET eid = EXCLUDED.eid;
    """
    # Change placeholders to named parameters using :cid, :eid
    try:
        # Create a connection to PostgreSQL
        engine = create_engine('postgresql://postgres:0624@localhost/Telco2')
        with engine.connect() as conn:
            print("Inserting data...")
            # Use a dictionary for binding parameters
            conn.execute(text(insert_query), [{'cid': cid, 'eid': eid} for cid, eid in data])
            conn.commit()  # Commit the transaction to save the changes
            print("Data inserted successfully.")
    except Exception as e:
        print(f"Error occurred: {e}")

# Fetch data and prepare GeoDataFrame
cid_df, eid_df = fetch_data()

# Apply K-Means clustering
cid_gdf = apply_kmeans_per_market(cid_df, eid_df)

# Assign EIDs to clusters
assignments_df = assign_eids_to_clusters(cid_gdf, eid_df)


print(assignments_df.head())  # Check the first few rows of the dataframe
print(len(assignments_df))  # Check the length of the dataframe

# Insert assignments into the database
insert_assignments(assignments_df)
